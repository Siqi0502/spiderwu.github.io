---
layout:     post
title:      MySQL数据库进阶
subtitle:   必知必会
date:       2019-08-05
author:     SQ
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - 数据库
    - MySQL
    - 存储引擎
    - 语句执行计划
---
## 写在前面

本文将以问答形式对MySQL进行更进一步的学习。



Q1：MySQL数据库有哪些存储引擎，**InnoDB**存储引擎和**MyISM**存储引擎的区别？

> 主要有：
>
> MyISM：MyISAM存储引擎：不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有要求或者以select，insert为主的应用基本上可以用这个引擎来创建表。
>
> InnoDB：支持事务
>
> Memory：Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式为.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。 
>
> Merge：Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。
>
> MyISM和InnoDB的区别：
>
> InnoDB支持事务，而MyISM不支持事务
> InnoDB支持行级锁，而MyISM支持表级锁
> InnoDB支持外键，而MyISM不支持
> InnoDB支持全文索引，而MyISM不支持
> InnoDB是索引组织表，MyISM是堆表 (堆表的数据是随机插入的，索引组织表的数据是有序的)



Q2：MySQL中**char**和**varchar**的区别，varchar(50)和char(50)分别代表什么意思

> char(50): 定长，字符的长度为50，浪费空间，存取速度快，数据不足时，会往右填充空格来满足长度。
>
>  varchar(50): 变长，字符的长度为50，节省空间，存取速度慢，存储数据的真实内容，不会填充空格，且会在真实数据前加1-2bytes,表示真实数据的bytes字节数。



Q3：MySQL中**int**类型存储多少个字节？

> int存储4字节，最小值-2147483648，最大值21477483647



Q4：**主键**具有什么特征

> 唯一且非空



Q5：**inner join**、**left join**、**right join**、**full join**的用法和区别

> 均用于多表连接查询
>
> inner join： 内连接，只连接匹配的行，找两张表共有的部分；
>
> left join: 外连接之左连接，优先显示左表全部记录，在内连接的基础上增加左表有右表没有的结果；
>
> right join: 外连接之右连接，优先显示右表全部记录，在内连接的基础上增加右表有左表没有的结果；
>
> full join: = left join on union right join on ... mysql 不支持full join 但是可以用 union ...全外连接，显示左右两个表全部记录，在内连接的基础上增加左表有右表没有和右表有左表没有的结果；



Q6：**select**语句的执行顺序

> from							#找到表
> where						 #指定的约束条件，去文件/表中取出一条条记录
> group by					#将记录进行分组
> having						#分组结果进行过滤
> select						  #执行select
> distinct					   #去重
> order by					 #将结果进行排序
> limit							#限制结果的显示条数



Q7：**数据备份**分为哪几种类型？增量备份和差异备份的区别是什么？

> 完整备份：备份系统中的所有数据。特点：占用空间大，备份速度慢，但恢复时一次恢复到位，恢复速度快。
>
> 增量备份：只备份上次备份以后有变化的数据。
> 特点：因每次仅备份自上一次备份（注意是上一次，不是第一次）以来有变化的文件，所以备份体积小，备份速度快，但是恢复的时候，需要按备份时间顺序，逐个备份版本进行恢复，恢复时间长。
>
> 差异备份：只备份上次完全备份以后有变化的数据。
> 特点：占用空间比增量备份大，比完整备份小，恢复时仅需要恢复第一个完整版本和最后一次的差异版本，恢复速度介于完整备份和增量备份之间。
>
> 简单的讲，完整备份就是不管三七二十一，每次都把指定的备份目录完整的复制一遍，不管目录下的文件有没有变化；
> 增量备份就是每次将之前（第一次、第二次、直到前一次）做过备份之后有变化的文件进行备份；
> 差异备份就是每次都将第一次完整备份以来有变化的文件进行备份。



Q8：**hash**索引和**B+树**索引的实现原理

> 哈希索引基于哈希表实现，只有精确匹配索引的所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。
>
> 哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。也就是说，由于哈希查找比起B-Tree索引，其本身对于单行查询的时间复杂度更低，有了哈希索引后明显可加快单行查询速度。
>
> 但是哈希索引也有它自己的限制：
> 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。
>
> 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。
> 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如，在数据列(A, B)上建立哈希索引，如果查询只有数据列A，则无法使用该索引。
>
> 哈希索引只支持等值比较查询，包括=、in()、<=>。不支持任何范围查询，例如where price > 100。访问哈希索引的数据非常快，除非有很多哈希冲突。如果哈希冲突很多的话，一些索引维护操作的代价也很高。
>
> B+树索引是B树索引的变体，本质上也是多路平衡查找树



Q9：什么是**视图**，简单介绍视图的作用和使用场景？

> 视图是一个虚拟表（非真实存在），其本质是【根据SQL语句获取动态的数据集，并为其命名】，
> 用户使用时只需使用【名称】即可获取结果集，可以将该结果集当做表来使用。
>
> 视图取代复杂的sql语句，方便用来查询。
>
> 语句：create view teacher_view as select tid from teacher where tname='李平老师';



Q10：什么是**存储过程**，存储过程的作用是什么？

> 存储过程包含了一系列可执行的sql语句，存储过程存放于MySQL中，通过调用它的名字可以执行其内部的一堆sql。
> 优点：
>
> 1. 用于替代程序写的SQL语句，实现程序与sql解耦
> 2. 基于网络传输，传别名的数据量小，而直接传sql数据量大
>
> 缺点：
>
> 1. 程序员扩展功能不方便



Q11：什么是**触发器**，请简述触发器的使用场景？

> 使用触发器可以定制用户对表进行【增、删、改】操作时前后的行为，注意：没有查询。
>
> 触发器无法由用户直接调用，而只能由于对表的【增/删/改】操作被动引发的。



Q12：**ACID**代表什么意思，什么业务场景需要支持事务，什么业务场景不需要支持事务？

> ACID，指数据库事务正确执行的四个基本要素的缩写。
> 包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
> 一个支持事务（Transaction）的数据库，必须要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性。
>
> 使用场景：
> 银行的交易系统
>
> start transaction; 
> update user set balance = 900 where name = 'wsb'; 					#买支付100元
> update user set balance = 1010 where name = 'egon'; 				#中介拿走10元
> uppdate user set balance = 1090 where name = 'ysb'; 				#卖家拿到90元,出现异常没有拿到
> rollback;
> commit;



Q13：**索引**的本质是什么？索引的优缺点

> 索引是帮助MySQL高效获取数据的数据结构。因此，索引的本质是一种数据结构。
> 在数据之外，数据库系统还可以维护满足特定查找算法的数据结构，这些数据结构以某种方式指向真实数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。
>
> 优点：
> 1、提高数据检索效率，降低数据库的IO成本；
> 2、通过索引对数据进行排序，降低了数据排序的成本，降低了CPU的利用率；
>
> 缺点：
> 1、索引实际上也是一张表，索引会占用一定的存储空间；
> 2、更新数据表的数据时，需要同时维护索引表，因此，会降低insert、update、delete的速度；



Q14：哪些情况下需要**创建索引**，哪些情况下不需要创建索引？

> 1、主键自动创建唯一非空索引；
> 2、频繁作为查询条件的字段应该创建索引；
> 3、频繁更新的字段不适合简历索引，因为每次更新不仅仅更新数据表同时还会更新索引表；
> 4、查询中经常排序的字段，可以考虑创建索引；
> 5、如果某个字段的重复数据较多，不适合创建普通索引；



Q15：**事务**的实现原理。

> 事务：用于将某些操作的多个sql作为原子性操作，一旦有某一个出现错误，即可回滚到原来的状态，从而保证数据库数据的完整性。
>
> 原子性：一堆sql语句，要么同时执行成功，要么同时失败！



Q16：**concat**, **group_concat**函数的作用。

> 定义显示格式：
>
> concat() 		  用于连接字符串 
> 　　eg: select concat('姓名：',name,'年薪：',salasy*12) as annual_salary from employee;
>
> concat_ws() 	第一个参数为分隔符
> 　　eg: select concat_ws(':',name,salary*12) as annual_salary from employee;
>
> group by 与 group_concat() 函数一起使用
> 　　select post,group_concat(name) as emp_members from employee group by post;



Q17：如何查看SQL语句的**执行计划**？

> 执行计划的查看是进行数据库的sql语句调优时依据的一个重要依据。关键词：explain
>
> 语句：explain select * from class;
>
> 参数解释：
>
> Id：包含一组数字，表示查询中执行select子句或操作表的顺序；执行顺序从大到小执行；当id值一样的时候，执行顺序由上往下；
>
> Select_type:表示查询中每个select子句的类型（简单OR复杂），有以下几种:
>
> - SIMPLE：查询中不包含子查询或者UNION
> - PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY
> - SUBQUERY：在SELECT或WHERE列表中包含了子查询，该子查询被标记为SUBQUERY
> - DERIVED：在FROM列表中包含的子查询被标记为DERIVED（衍生）
> - 若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED；从UNION表获取结果的SELECT被标记为：UNION RESULT
>
> Type：表示MySQL在表中找到所需行的方式，又称“访问类型”，常见有以下几种:
>
> - ALL：Full Table Scan， MySQL将进行全表扫描；
> - index：Full Index Scan，index与ALL区别为index类型只遍历索引树；
> - range：range Index Scan，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、<、>等的查询；
> - ref：非唯一性索引扫描，返回匹配摸个单独值的所有行。常见于使用非唯一索引或唯一索引的非唯一前缀进行的查找；
> - eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描
>     const、system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量
> - NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引
>
> possible_keys：指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用； 
>
> key：显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。当查询中若使用了覆盖索引，则该索引仅出现在key列表中
>
> key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度
>
> ref：表示上述表的连接匹配条件，即那些列或常量被用于查找索引列上的值；
>
> rows：表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数；
>
> Extra：包含不适合在其他列中显示但十分重要的额外信息；
>
> Using where：表示MySQL服务器在存储引擎受到记录后进行“后过滤”（Post-filter）,如果查询未能使用索引，Using where的作用只是提醒我们MySQL将用where子句来过滤结果集
>
> Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询；
>
> Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”；



未完待续～